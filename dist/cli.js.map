{"version":3,"file":"cli.js","names":["__filename","__dirname","#workingDir","#puprcFilePath","#config","#workflows","#checks","#versionFiles","puprcDefaults","#i18n"],"sources":["../src/utils/directory.ts","../src/models/workflow.ts","../src/schemas.ts","../defaults/.puprc-defaults.json","../src/config.ts","../src/app.ts","../src/utils/process.ts","../src/utils/output.ts","../src/commands/build.ts","../src/cli.ts"],"sourcesContent":["import path from 'node:path';\nimport fs from 'fs-extra';\n\n/**\n * Checks whether a child directory is inside a parent directory.\n *\n * @since TBD\n *\n * @param {string} parentDir - The parent directory path.\n * @param {string} childDir - The child directory path.\n *\n * @returns {boolean} True if childDir is inside parentDir.\n */\nexport function isInside(parentDir: string, childDir: string): boolean {\n  const relative = path.relative(parentDir, childDir);\n  return !!relative && !relative.startsWith('..') && !path.isAbsolute(relative);\n}\n\n/**\n * Ensures a directory path ends with a trailing separator.\n *\n * @since TBD\n *\n * @param {string} p - The path to ensure has a trailing separator.\n *\n * @returns {string} The path with a trailing separator.\n *\n * @throws {Error} If the path appears to be a file (has an extension).\n */\nexport function trailingSlashIt(p: string): string {\n  const { dir, base, ext } = path.parse(p);\n\n  if (ext.length > 0) {\n    throw new Error('Could not add trailing slash to file path.');\n  }\n\n  return path.join(dir, base, path.sep);\n}\n\n/**\n * Removes a directory, but only if it is within the given working directory.\n *\n * @since TBD\n *\n * @param {string} dir - The directory path to remove.\n * @param {string} workingDir - The working directory that the target must be within.\n *\n * @returns {void}\n *\n * @throws {Error} If the directory is outside the working directory.\n */\nexport async function rmdir(dir: string, workingDir: string): Promise<void> {\n  const relative = path.relative(workingDir, dir);\n  const inside = relative && !relative.startsWith('..') && !path.isAbsolute(relative);\n\n  // Safety check: only remove directories within the working directory\n  if (!inside) {\n    throw new Error(\n      `Refusing to remove directory outside working directory: ${dir}`\n    );\n  }\n\n  if (await fs.pathExists(dir)) {\n    await fs.remove(dir);\n  }\n}\n\n/**\n * Resolves a relative path against a working directory.\n * Rejects absolute paths unless a default is provided.\n *\n * @since TBD\n *\n * @param {string} relativePath - The relative path to resolve.\n * @param {string} workingDir - The working directory to resolve against.\n * @param {string} [defaultPath] - Optional default path to use if an absolute path is given.\n *\n * @returns {string} The resolved absolute path.\n *\n * @throws {Error} If an absolute path is given without a default fallback.\n */\nexport function resolveRelativePath(\n  relativePath: string,\n  workingDir: string,\n  defaultPath?: string\n): string {\n  if (path.isAbsolute(relativePath)) {\n    if (!defaultPath) {\n      throw new Error('Absolute paths are not allowed in the .puprc file.');\n    }\n\n    relativePath = defaultPath;\n  }\n\n  if (isInside(workingDir, relativePath)) {\n    return relativePath;\n  }\n\n  return path.join(workingDir, relativePath);\n}\n","import type { BuildStep, Workflow } from '../types.ts';\n\n/**\n * Creates a Workflow object from a slug and list of commands.\n *\n * @since TBD\n *\n * @param {string} slug - The unique identifier for the workflow.\n * @param {BuildStep[]} commands - The list of build steps to execute in the workflow.\n *\n * @returns {Workflow} A Workflow object with the provided slug and commands.\n */\nexport function createWorkflow(slug: string, commands: BuildStep[]): Workflow {\n  return { slug, commands };\n}\n\n/**\n * Manages a collection of named workflows.\n *\n * @since TBD\n */\nexport class WorkflowCollection {\n  private workflows: Map<string, Workflow> = new Map();\n\n  /**\n   * Adds a workflow to the collection.\n   *\n   * @since TBD\n   *\n   * @param {Workflow} workflow - The workflow to add.\n   *\n   * @returns {void}\n   */\n  add(workflow: Workflow): void {\n    this.workflows.set(workflow.slug, workflow);\n  }\n\n  /**\n   * Retrieves a workflow by its slug.\n   *\n   * @since TBD\n   *\n   * @param {string} slug - The slug of the workflow to retrieve.\n   *\n   * @returns {Workflow | undefined} The workflow if found, otherwise undefined.\n   */\n  get(slug: string): Workflow | undefined {\n    return this.workflows.get(slug);\n  }\n\n  /**\n   * Checks whether a workflow with the given slug exists.\n   *\n   * @since TBD\n   *\n   * @param {string} slug - The slug to check.\n   *\n   * @returns {boolean} True if the workflow exists, false otherwise.\n   */\n  has(slug: string): boolean {\n    return this.workflows.has(slug);\n  }\n\n  /**\n   * Returns all workflows as an array.\n   *\n   * @since TBD\n   *\n   * @returns {Workflow[]} An array containing all workflows in the collection.\n   */\n  getAll(): Workflow[] {\n    return Array.from(this.workflows.values());\n  }\n\n  /**\n   * Returns the number of workflows in the collection.\n   *\n   * @since TBD\n   *\n   * @returns {number} The count of workflows.\n   */\n  get size(): number {\n    return this.workflows.size;\n  }\n\n  /**\n   * Allows iterating over all workflows in the collection.\n   *\n   * @since TBD\n   *\n   * @returns {Iterator<Workflow>} An iterator over the workflows.\n   */\n  [Symbol.iterator](): Iterator<Workflow> {\n    return this.workflows.values();\n  }\n}\n","import { z } from 'zod';\n\n/**\n * A build step is either a single command string (run sequentially) or an\n * array of command strings (run in parallel).\n *\n * @since TBD\n */\nexport const BuildStepSchema = z.union([z.string(), z.array(z.string())]);\n\nexport type BuildStep = z.infer<typeof BuildStepSchema>;\n\n/**\n * Schema for a version file entry in .puprc paths.versions.\n *\n * @since TBD\n */\nexport const VersionFileInputSchema = z.object({\n  file: z.string(),\n  regex: z.string(),\n});\n\nexport type VersionFileInput = z.infer<typeof VersionFileInputSchema>;\n\n/**\n * Parsed version file (same shape as input).\n *\n * @since TBD\n */\nexport const VersionFileSchema = z.object({\n  file: z.string(),\n  regex: z.string(),\n});\n\nexport type VersionFile = z.infer<typeof VersionFileSchema>;\n\n/**\n * Schema for the i18n filter configuration.\n *\n * @since TBD\n */\nconst I18nFilterSchema = z.object({\n  minimum_percentage: z.number(),\n});\n\n/**\n * Schema for an i18n configuration entry from .puprc (all fields optional).\n *\n * @since TBD\n */\nexport const I18nConfigInputSchema = z.object({\n  path: z.string().optional(),\n  url: z.string().optional(),\n  slug: z.string().optional(),\n  textdomain: z.string().optional(),\n  file_format: z.string().optional(),\n  formats: z.array(z.string()).optional(),\n  filter: z.object({\n    minimum_percentage: z.number().optional(),\n  }).optional(),\n}).passthrough();\n\nexport type I18nConfigInput = z.infer<typeof I18nConfigInputSchema>;\n\n/**\n * Schema for the i18n defaults section of configuration.\n *\n * @since TBD\n */\nexport const I18nDefaultsSchema = z.object({\n  path: z.string(),\n  url: z.string(),\n  slug: z.string(),\n  textdomain: z.string(),\n  file_format: z.string(),\n  formats: z.array(z.string()),\n  filter: I18nFilterSchema,\n});\n\nexport type I18nDefaults = z.infer<typeof I18nDefaultsSchema>;\n\n/**\n * Schema for a fully resolved i18n configuration entry (all fields required).\n *\n * @since TBD\n */\nexport const I18nResolvedConfigSchema = z.object({\n  path: z.string(),\n  url: z.string(),\n  slug: z.string(),\n  textdomain: z.string(),\n  file_format: z.string(),\n  formats: z.array(z.string()),\n  filter: I18nFilterSchema,\n});\n\nexport type I18nResolvedConfig = z.infer<typeof I18nResolvedConfigSchema>;\n\n/**\n * Schema for a check configuration entry from .puprc (optional fields with defaults).\n *\n * @since TBD\n */\nexport const CheckConfigInputSchema = z.object({\n  fail_method: z.enum(['error', 'warn']).optional(),\n  fail_method_dev: z.enum(['error', 'warn']).optional(),\n  type: z.enum(['simple', 'class', 'pup', 'command']).optional(),\n  file: z.string().optional(),\n  command: z.string().optional(),\n  configure: z.string().optional(),\n  args: z.record(z.string(), z.string()).optional(),\n  dirs: z.array(z.string()).optional(),\n  skip_directories: z.string().optional(),\n  skip_files: z.string().optional(),\n}).passthrough();\n\nexport type CheckConfigInput = z.infer<typeof CheckConfigInputSchema>;\n\n/**\n * Schema for a fully resolved check configuration with defaults applied.\n *\n * @since TBD\n */\nexport const CheckConfigSchema = z.object({\n  slug: z.string(),\n  fail_method: z.enum(['error', 'warn']).default('error'),\n  fail_method_dev: z.enum(['error', 'warn']).default('warn'),\n  type: z.enum(['simple', 'class', 'pup', 'command']).default('pup'),\n  file: z.string().optional(),\n  command: z.string().optional(),\n  configure: z.string().optional(),\n  args: z.record(z.string(), z.string()).default({}),\n  dirs: z.array(z.string()).optional(),\n  skip_directories: z.string().optional(),\n  skip_files: z.string().optional(),\n});\n\nexport type CheckConfig = z.infer<typeof CheckConfigSchema>;\n\n/**\n * Schema for the paths section of configuration.\n *\n * @since TBD\n */\nexport const PathsConfigSchema = z.object({\n  build_dir: z.string(),\n  changelog: z.string().nullable(),\n  css: z.array(z.string()),\n  js: z.array(z.string()),\n  sync_files: z.array(z.string()),\n  versions: z.array(VersionFileInputSchema),\n  views: z.array(z.string()),\n  zip_dir: z.string(),\n});\n\nexport type PathsConfig = z.infer<typeof PathsConfigSchema>;\n\n/**\n * Schema for the full merged pup configuration (after defaults are applied).\n *\n * @since TBD\n */\nexport const PupConfigSchema = z.object({\n  build: z.array(BuildStepSchema),\n  build_dev: z.array(BuildStepSchema),\n  workflows: z.record(z.string(), z.array(z.string())),\n  checks: z.record(z.string(), CheckConfigInputSchema),\n  clean: z.array(z.string()),\n  i18n: z.union([z.array(I18nConfigInputSchema), I18nConfigInputSchema]),\n  i18n_defaults: I18nDefaultsSchema,\n  paths: PathsConfigSchema,\n  env: z.array(z.string()),\n  repo: z.string().nullable(),\n  zip_use_default_ignore: z.boolean(),\n  zip_name: z.string().nullable(),\n}).passthrough();\n\nexport type PupConfig = z.infer<typeof PupConfigSchema>;\n\n/**\n * Schema for validating raw .puprc input (all fields optional + passthrough for custom keys).\n *\n * @since TBD\n */\nexport const PuprcInputSchema = z.object({\n  build: z.array(BuildStepSchema).optional(),\n  build_dev: z.array(BuildStepSchema).optional(),\n  workflows: z.record(z.string(), z.array(z.string())).optional(),\n  checks: z.record(z.string(), CheckConfigInputSchema.or(z.object({}).passthrough())).optional(),\n  clean: z.array(z.string()).optional(),\n  i18n: z.union([z.array(I18nConfigInputSchema), I18nConfigInputSchema]).optional(),\n  i18n_defaults: I18nDefaultsSchema.partial().optional(),\n  paths: PathsConfigSchema.partial().optional(),\n  env: z.array(z.string()).optional(),\n  repo: z.string().nullable().optional(),\n  zip_use_default_ignore: z.boolean().optional(),\n  zip_name: z.string().nullable().optional(),\n}).passthrough();\n\nexport type PuprcInput = z.infer<typeof PuprcInputSchema>;\n\n/**\n * Schema for a workflow.\n *\n * @since TBD\n */\nexport const WorkflowSchema = z.object({\n  slug: z.string(),\n  commands: z.array(BuildStepSchema),\n});\n\nexport type Workflow = z.infer<typeof WorkflowSchema>;\n\n/**\n * Result of running a check.\n *\n * @since TBD\n */\nexport interface CheckResult {\n  success: boolean;\n  output: string;\n}\n\n/**\n * Result of running a shell command.\n *\n * @since TBD\n */\nexport interface RunCommandResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n","","import fs from 'fs-extra';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { trailingSlashIt } from './utils/directory.ts';\nimport { WorkflowCollection, createWorkflow } from './models/workflow.ts';\nimport { PuprcInputSchema, CheckConfigSchema } from './schemas.ts';\nimport type {\n  PupConfig,\n  BuildStep,\n  CheckConfig,\n  VersionFile,\n  VersionFileInput,\n  I18nResolvedConfig,\n  I18nConfigInput,\n} from './types.ts';\nimport puprcDefaults from '../defaults/.puprc-defaults.json';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Locates the defaults directory containing .distignore-defaults and docs.\n *\n * @since TBD\n *\n * @returns {string} The absolute path to the defaults directory.\n */\nexport function getDefaultsDir(): string {\n  // In built dist, defaults/ is at the package root\n  // During dev, it's at the repo root\n  const candidates = [\n    path.resolve(__dirname, '..', 'defaults'),\n    path.resolve(__dirname, '..', '..', 'defaults'),\n  ];\n\n  for (const candidate of candidates) {\n    if (fs.existsSync(candidate)) {\n      return candidate;\n    }\n  }\n\n  return candidates[0];\n}\n\n/**\n * Loads, merges, and provides access to the project's pup configuration.\n *\n * @since TBD\n */\nexport class Config {\n  readonly #workingDir: string;\n  readonly #puprcFilePath: string;\n  readonly #config: PupConfig;\n  #workflows: WorkflowCollection;\n  #checks: Map<string, CheckConfig>;\n  #versionFiles: VersionFile[];\n  #i18n: I18nResolvedConfig[] | null = null;\n\n  /**\n   * Initializes configuration by loading and merging .puprc with defaults.\n   *\n   * @since TBD\n   *\n   * @param {string} workingDir - The project working directory. Defaults to process.cwd().\n   *\n   * @throws {Error} If the .puprc file is present but contains invalid JSON or fails validation.\n   */\n  constructor(workingDir?: string) {\n    const cwd = workingDir ?? process.cwd();\n\n    this.#workingDir = trailingSlashIt(path.normalize(cwd));\n    this.#puprcFilePath = path.join(this.#workingDir, '.puprc');\n    this.#config = this.getDefaultConfig();\n    this.mergeConfigWithDefaults();\n    this.#workflows = this.buildWorkflows();\n    this.#checks = this.parseCheckConfig();\n    this.#versionFiles = this.parseVersionFiles();\n  }\n\n  /**\n   * Returns the default configuration from the bundled .puprc-defaults.\n   *\n   * @since TBD\n   *\n   * @returns {PupConfig} The parsed default configuration object.\n   */\n  private getDefaultConfig(): PupConfig {\n    return structuredClone(puprcDefaults) as PupConfig;\n  }\n\n  /**\n   * Merges the project's .puprc file into the default configuration.\n   *\n   * @since TBD\n   *\n   * @throws {Error} If the .puprc file contains invalid JSON or fails schema validation.\n   */\n  private mergeConfigWithDefaults(): void {\n    if (!fs.existsSync(this.#puprcFilePath)) {\n      return;\n    }\n\n    const puprcContents = fs.readFileSync(this.#puprcFilePath, 'utf-8');\n    let rawPuprc: unknown;\n\n    try {\n      rawPuprc = JSON.parse(puprcContents);\n    } catch {\n      throw new Error(\n        'There is a .puprc file in this directory, but it could not be parsed. Invalid JSON in .puprc.'\n      );\n    }\n\n    if (!rawPuprc || typeof rawPuprc !== 'object') {\n      throw new Error(\n        'There is a .puprc file in this directory, but it could not be parsed. Invalid .puprc format.'\n      );\n    }\n\n    const parseResult = PuprcInputSchema.safeParse(rawPuprc);\n\n    if (!parseResult.success) {\n      const issues = parseResult.error.issues\n        .map((issue) => `  ${issue.path.join('.')}: ${issue.message}`)\n        .join('\\n');\n      throw new Error(\n        `There is a .puprc file in this directory, but it contains invalid configuration:\\n${issues}`\n      );\n    }\n\n    const puprc = parseResult.data as Record<string, unknown>;\n    const configRecord = this.#config as unknown as Record<string, unknown>;\n\n    for (const [key, value] of Object.entries(puprc)) {\n      const current = configRecord[key];\n\n      if (current === undefined || current === null) {\n        configRecord[key] = value;\n        continue;\n      }\n\n      if (typeof current !== 'object') {\n        configRecord[key] = value;\n        continue;\n      }\n\n      // Special handling for checks: preserve defaults + merge\n      if (key === 'checks' && typeof value === 'object' && value !== null) {\n        const defaultChecks = current as Record<string, unknown>;\n        const newChecks = value as Record<string, unknown>;\n        configRecord[key] = newChecks;\n\n        for (const [checkSlug, checkConfig] of Object.entries(newChecks)) {\n          if (defaultChecks[checkSlug] !== undefined) {\n            (configRecord[key] as Record<string, unknown>)[checkSlug] =\n              this.mergeConfigValue(defaultChecks[checkSlug], checkConfig);\n          }\n        }\n        continue;\n      }\n\n      configRecord[key] = this.mergeConfigValue(current, value);\n    }\n  }\n\n  /**\n   * Deep-merges two configuration values. Scalars and arrays replace; objects merge recursively.\n   *\n   * @since TBD\n   *\n   * @param {unknown} original - The original configuration value.\n   * @param {unknown} newVal - The new configuration value to merge in.\n   *\n   * @returns {unknown} The merged configuration value.\n   */\n  private mergeConfigValue(original: unknown, newVal: unknown): unknown {\n    if (typeof newVal !== 'object' || newVal === null) {\n      return newVal;\n    }\n\n    if (typeof original !== 'object' || original === null) {\n      return newVal;\n    }\n\n    if (Array.isArray(original)) {\n      // Numeric-keyed arrays: replace\n      return newVal;\n    }\n\n    if (Array.isArray(newVal)) {\n      return newVal;\n    }\n\n    const orig = original as Record<string, unknown>;\n    const nv = newVal as Record<string, unknown>;\n    const result = { ...orig };\n\n    for (const [key, item] of Object.entries(orig)) {\n      if (nv[key] === undefined) continue;\n      if (typeof item === 'object' && item !== null && !Array.isArray(item)) {\n        result[key] = this.mergeConfigValue(item, nv[key]);\n      } else {\n        result[key] = nv[key];\n      }\n    }\n\n    for (const [key, item] of Object.entries(nv)) {\n      if (result[key] === undefined) {\n        result[key] = item;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Builds the workflow collection from configuration, including auto-generated build workflows.\n   *\n   * @since TBD\n   *\n   * @returns {WorkflowCollection} The built workflow collection.\n   */\n  private buildWorkflows(): WorkflowCollection {\n    const collection = new WorkflowCollection();\n\n    const rawWorkflows = this.#config.workflows as unknown;\n\n    // Auto-create build workflow\n    // TODO: Add parallel build step support to workflow execution.\n    if (\n      this.#config.build?.length > 0 &&\n      !(rawWorkflows as Record<string, unknown>)?.['build']\n    ) {\n      collection.add(createWorkflow('build', this.#config.build));\n    }\n\n    if (\n      this.#config.build_dev?.length > 0 &&\n      !(rawWorkflows as Record<string, unknown>)?.['build_dev']\n    ) {\n      collection.add(createWorkflow('build_dev', this.#config.build_dev));\n    }\n\n    if (rawWorkflows && typeof rawWorkflows === 'object') {\n      for (const [slug, commands] of Object.entries(\n        rawWorkflows as Record<string, string[]>\n      )) {\n        collection.add(\n          createWorkflow(slug, Array.isArray(commands) ? commands : [])\n        );\n      }\n    }\n\n    return collection;\n  }\n\n  /**\n   * Parses the checks section of the configuration into CheckConfig objects.\n   * Uses Zod schema defaults for per-field values.\n   *\n   * @since TBD\n   *\n   * @returns {Map<string, CheckConfig>} A map of check slug to CheckConfig.\n   */\n  private parseCheckConfig(): Map<string, CheckConfig> {\n    const checks = this.#config.checks;\n    const result = new Map<string, CheckConfig>();\n    if (!checks) return result;\n\n    for (const [slug, checkInput] of Object.entries(checks)) {\n      const input = typeof checkInput === 'object' && checkInput !== null\n        ? checkInput\n        : {};\n\n      const parsed = CheckConfigSchema.parse({ slug, ...input });\n      result.set(slug, parsed);\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses and validates the version files section of the configuration.\n   *\n   * @since TBD\n   *\n   * @returns {VersionFile[]} The parsed list of version file objects.\n   *\n   * @throws {Error} If a version file entry is missing required properties or the file does not exist.\n   */\n  private parseVersionFiles(): VersionFile[] {\n    const versions = this.#config.paths?.versions;\n    const result: VersionFile[] = [];\n    if (!versions || !Array.isArray(versions)) return result;\n\n    for (const vf of versions as VersionFileInput[]) {\n      if (!vf.file || !vf.regex) {\n        throw new Error(\n          'Versions specified in .puprc .paths.versions must have the \"file\" and \"regex\" property.'\n        );\n      }\n\n      const filePath = path.join(this.#workingDir, vf.file);\n      if (!fs.existsSync(filePath)) {\n        throw new Error(`Version file does not exist: ${vf.file}`);\n      }\n\n      const contents = fs.readFileSync(filePath, 'utf-8');\n      const regex = new RegExp(vf.regex);\n      const matches = contents.match(regex);\n\n      if (!matches || !matches[1] || !matches[2]) {\n        throw new Error(\n          `Could not find version in file ${vf.file} using regex \"/${vf.regex}/\"`\n        );\n      }\n\n      result.push({ file: vf.file, regex: vf.regex });\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the raw merged configuration object.\n   *\n   * @since TBD\n   *\n   * @returns {PupConfig} The configuration object.\n   */\n  get raw(): PupConfig {\n    return this.#config;\n  }\n\n  /**\n   * Returns the build commands, preferring dev commands when isDev is true.\n   *\n   * @since TBD\n   *\n   * @param {boolean} isDev - Whether to return dev build commands.\n   *\n   * @returns {BuildStep[]} The list of build steps (strings run sequentially, sub-arrays run in parallel).\n   */\n  getBuildCommands(isDev = false): BuildStep[] {\n    if (isDev && this.#config.build_dev?.length > 0) {\n      return this.#config.build_dev;\n    }\n    return this.#config.build ?? [];\n  }\n\n  /**\n   * Returns the build directory path, optionally as a full absolute path.\n   *\n   * @since TBD\n   *\n   * @param {boolean} fullPath - Whether to return the full absolute path.\n   *\n   * @returns {string} The build directory path.\n   */\n  getBuildDir(fullPath = true): string {\n    const buildDir = this.#config.paths?.build_dir ?? '.pup-build';\n    if (!fullPath) return buildDir;\n    return path.resolve(this.#workingDir, buildDir);\n  }\n\n  /**\n   * Returns the clean commands from the configuration.\n   *\n   * @since TBD\n   *\n   * @returns {string[]} The list of clean command strings.\n   */\n  getCleanCommands(): string[] {\n    return this.#config.clean ?? [];\n  }\n\n  /**\n   * Returns the map of parsed check configurations.\n   *\n   * @since TBD\n   *\n   * @returns {Map<string, CheckConfig>} A map of check slug to CheckConfig.\n   */\n  getChecks(): Map<string, CheckConfig> {\n    return this.#checks;\n  }\n\n  /**\n   * Returns resolved i18n configurations, merging with defaults.\n   *\n   * @since TBD\n   *\n   * @returns {I18nResolvedConfig[]} The list of resolved i18n configuration objects.\n   */\n  getI18n(): I18nResolvedConfig[] {\n    if (this.#i18n !== null) return this.#i18n;\n\n    const defaults = this.#config.i18n_defaults;\n    const i18nRaw = this.#config.i18n;\n\n    if (!i18nRaw || (Array.isArray(i18nRaw) && i18nRaw.length === 0)) {\n      this.#i18n = [];\n      return this.#i18n;\n    }\n\n    // Normalize to array\n    let i18nArr: I18nConfigInput[];\n    if (!Array.isArray(i18nRaw)) {\n      i18nArr = [i18nRaw];\n    } else {\n      i18nArr = i18nRaw;\n    }\n\n    // Filter valid entries\n    i18nArr = i18nArr.filter(\n      (item) => item.url && item.textdomain && item.slug\n    );\n\n    if (i18nArr.length === 0) {\n      this.#i18n = [];\n      return this.#i18n;\n    }\n\n    this.#i18n = i18nArr.map((item) => ({\n      path: item.path ?? defaults.path,\n      url: item.url ?? defaults.url,\n      slug: item.slug ?? defaults.slug,\n      textdomain: item.textdomain ?? defaults.textdomain,\n      file_format: item.file_format ?? defaults.file_format,\n      formats: item.formats?.length ? item.formats : defaults.formats,\n      filter: {\n        minimum_percentage:\n          item.filter?.minimum_percentage ??\n          defaults.filter.minimum_percentage,\n      },\n    }));\n\n    return this.#i18n;\n  }\n\n  /**\n   * Returns the list of environment variable names from configuration.\n   *\n   * @since TBD\n   *\n   * @returns {string[]} The list of environment variable name strings.\n   */\n  getEnvVarNames(): string[] {\n    return this.#config.env ?? [];\n  }\n\n  /**\n   * Returns the git repository URL, inferring from package.json or composer.json if not set.\n   *\n   * @since TBD\n   *\n   * @returns {string} The git repository URL string.\n   *\n   * @throws {Error} If no repository can be determined.\n   */\n  getRepo(): string {\n    if (!this.#config.repo) {\n      // Try to infer from package.json\n      const pkgPath = path.join(this.#workingDir, 'package.json');\n      if (fs.existsSync(pkgPath)) {\n        const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8')) as {\n          repository?: { url?: string } | string;\n        };\n        if (typeof pkg.repository === 'string') {\n          return `git@github.com:${pkg.repository}.git`;\n        }\n        if (pkg.repository?.url) {\n          return pkg.repository.url;\n        }\n      }\n\n      // Try composer.json fallback\n      const composerPath = path.join(this.#workingDir, 'composer.json');\n      if (fs.existsSync(composerPath)) {\n        const composer = JSON.parse(\n          fs.readFileSync(composerPath, 'utf-8')\n        ) as { name?: string };\n        if (composer.name) {\n          return `git@github.com:${composer.name}.git`;\n        }\n      }\n\n      throw new Error(\n        'Could not find a repo in the .puprc file or the \"name\" property in package.json/composer.json.'\n      );\n    }\n\n    const repo = this.#config.repo;\n\n    if (\n      !repo.includes('https://') &&\n      !repo.includes('file://') &&\n      !repo.includes('git://') &&\n      !repo.includes('git@github.com') &&\n      !fs.existsSync(repo)\n    ) {\n      return `git@github.com:${repo}.git`;\n    }\n\n    return repo;\n  }\n\n  /**\n   * Returns the list of sync file names (.distfiles, .distinclude, etc.).\n   *\n   * @since TBD\n   *\n   * @returns {string[]} The list of sync file name strings.\n   */\n  getSyncFiles(): string[] {\n    const defaults = ['.distfiles', '.distinclude', '.distignore', '.gitattributes'];\n    const configFiles = this.#config.paths?.sync_files;\n\n    if (!configFiles || !Array.isArray(configFiles) || configFiles.length === 0) {\n      return defaults;\n    }\n\n    return [...new Set([...defaults, ...configFiles])];\n  }\n\n  /**\n   * Returns the parsed version file configurations.\n   *\n   * @since TBD\n   *\n   * @returns {VersionFile[]} The list of version file objects.\n   */\n  getVersionFiles(): VersionFile[] {\n    return this.#versionFiles;\n  }\n\n  /**\n   * Returns the workflow collection.\n   *\n   * @since TBD\n   *\n   * @returns {WorkflowCollection} The WorkflowCollection instance.\n   */\n  getWorkflows(): WorkflowCollection {\n    return this.#workflows;\n  }\n\n  /**\n   * Returns the working directory path.\n   *\n   * @since TBD\n   *\n   * @returns {string} The absolute working directory path with trailing slash.\n   */\n  getWorkingDir(): string {\n    return this.#workingDir;\n  }\n\n  /**\n   * Returns the zip staging directory path, optionally as a full absolute path.\n   *\n   * @since TBD\n   *\n   * @param {boolean} fullPath - Whether to return the full absolute path.\n   *\n   * @returns {string} The zip staging directory path.\n   */\n  getZipDir(fullPath = true): string {\n    const zipDir = this.#config.paths?.zip_dir ?? '.pup-zip';\n    if (!fullPath) return zipDir;\n    return path.resolve(this.#workingDir, zipDir);\n  }\n\n  /**\n   * Returns the zip archive base name, inferring from package.json if not set.\n   *\n   * @since TBD\n   *\n   * @returns {string} The zip archive base name string.\n   *\n   * @throws {Error} If no zip name can be determined.\n   */\n  getZipName(): string {\n    if (this.#config.zip_name) {\n      return this.#config.zip_name;\n    }\n\n    // Try package.json name\n    const pkgPath = path.join(this.#workingDir, 'package.json');\n    if (fs.existsSync(pkgPath)) {\n      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8')) as {\n        name?: string;\n      };\n      if (pkg.name) {\n        // Strip scope prefix (e.g., @stellarwp/pup -> pup)\n        return pkg.name.replace(/^@[^/]+\\//, '');\n      }\n    }\n\n    // Try composer.json name\n    const composerPath = path.join(this.#workingDir, 'composer.json');\n    if (fs.existsSync(composerPath)) {\n      const composer = JSON.parse(\n        fs.readFileSync(composerPath, 'utf-8')\n      ) as { name?: string };\n      if (composer.name) {\n        return composer.name.replace(/^[^/]+\\//, '');\n      }\n    }\n\n    throw new Error('Could not find a \"zip_name\" in .puprc');\n  }\n\n  /**\n   * Returns whether to use the default .distignore-defaults patterns.\n   *\n   * @since TBD\n   *\n   * @returns {boolean} True if default ignore patterns should be used.\n   */\n  getZipUseDefaultIgnore(): boolean {\n    return this.#config.zip_use_default_ignore ?? true;\n  }\n\n  /**\n   * Serializes the configuration to a plain object.\n   *\n   * @since TBD\n   *\n   * @returns {PupConfig} The configuration as a PupConfig object.\n   */\n  toJSON(): PupConfig {\n    return this.#config;\n  }\n}\n\nlet globalConfig: Config | null = null;\n\n/**\n * Returns the singleton Config instance, creating it if needed.\n *\n * @since TBD\n *\n * @param {string} workingDir - Optional working directory to pass to the Config constructor.\n *\n * @returns {Config} The singleton Config instance.\n */\nexport function getConfig(workingDir?: string): Config {\n  if (!globalConfig) {\n    globalConfig = new Config(workingDir);\n  }\n  return globalConfig;\n}\n\n/**\n * Resets the singleton Config instance, forcing a fresh load on next access.\n *\n * @since TBD\n *\n * @returns {void}\n */\nexport function resetConfig(): void {\n  globalConfig = null;\n}\n","import { Command } from 'commander';\nimport { Config, getConfig, resetConfig } from './config.ts';\nimport { fileURLToPath } from 'node:url';\nimport path from 'node:path';\nimport fs from 'fs-extra';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Reads the pup version from the nearest package.json.\n *\n * @since TBD\n *\n * @returns {string} The version string from package.json, or '2.0.0' as a fallback.\n */\nfunction getVersion(): string {\n  // Try to read from package.json\n  const candidates = [\n    path.resolve(__dirname, '..', 'package.json'),\n    path.resolve(__dirname, '..', '..', 'package.json'),\n  ];\n\n  for (const candidate of candidates) {\n    if (fs.existsSync(candidate)) {\n      const pkg = JSON.parse(fs.readFileSync(candidate, 'utf-8')) as { version: string };\n      return pkg.version;\n    }\n  }\n\n  return '2.0.0';\n}\n\nexport const PUP_VERSION = getVersion();\n\n/**\n * Creates and configures the Commander program instance.\n *\n * @since TBD\n *\n * @returns {Command} The configured Commander program.\n */\nexport function createApp(): Command {\n  resetConfig();\n\n  getConfig();\n\n  const program = new Command();\n  program\n    .name('pup')\n    .version(PUP_VERSION)\n    .description(\"StellarWP's Project Utilities & Packager\");\n\n  return program;\n}\n\nexport { Config, getConfig, resetConfig };\n","import { execa } from 'execa';\nimport type { RunCommandResult } from '../types.ts';\n\nexport interface RunOptions {\n  cwd?: string;\n  softFail?: boolean;\n  silent?: boolean;\n}\n\n/**\n * Runs a shell command, streaming output to console.\n * Commands prefixed with `@` are treated as soft-fail (errors are ignored).\n *\n * @since TBD\n *\n * @param {string} command - The shell command to execute.\n * @param {RunOptions} options - Optional configuration for the command execution.\n *\n * @returns {Promise<RunCommandResult>} The command result with stdout, stderr, and exit code.\n */\nexport async function runCommand(\n  command: string,\n  options: RunOptions = {}\n): Promise<RunCommandResult> {\n  let cmd = command;\n  let softFail = options.softFail ?? false;\n\n  // Handle @ prefix for soft-fail\n  if (cmd.startsWith('@')) {\n    cmd = cmd.slice(1);\n    softFail = true;\n  }\n\n  try {\n    const result = await execa(cmd, {\n      cwd: options.cwd,\n      shell: true,\n      stdout: options.silent ? 'pipe' : 'inherit',\n      stderr: options.silent ? 'pipe' : 'inherit',\n      reject: false,\n    });\n\n    if (result.exitCode !== 0 && !softFail) {\n      return {\n        stdout: String(result.stdout ?? ''),\n        stderr: String(result.stderr ?? ''),\n        exitCode: result.exitCode ?? 1,\n      };\n    }\n\n    return {\n      stdout: String(result.stdout ?? ''),\n      stderr: String(result.stderr ?? ''),\n      exitCode: softFail ? 0 : (result.exitCode ?? 0),\n    };\n  } catch (err: unknown) {\n    if (softFail) {\n      return { stdout: '', stderr: String(err), exitCode: 0 };\n    }\n    throw err;\n  }\n}\n\n/**\n * Runs a command and captures the output silently.\n *\n * @since TBD\n *\n * @param {string} command - The shell command to execute.\n * @param {Omit<RunOptions, 'silent'>} options - Optional configuration for the command execution.\n *\n * @returns {Promise<RunCommandResult>} The command result with stdout, stderr, and exit code.\n */\nexport async function runCommandSilent(\n  command: string,\n  options: Omit<RunOptions, 'silent'> = {}\n): Promise<RunCommandResult> {\n  return runCommand(command, { ...options, silent: true });\n}\n","import chalk from 'chalk';\n\nlet prefix = '';\n\n/**\n * Sets a prefix string that will be prepended to all output messages.\n *\n * @since TBD\n *\n * @param {string} p - The prefix string.\n *\n * @returns {void}\n */\nexport function setPrefix(p: string): void {\n  prefix = p;\n}\n\n/**\n * Returns the current output prefix.\n *\n * @since TBD\n *\n * @returns {string} The current prefix string.\n */\nexport function getPrefix(): string {\n  return prefix;\n}\n\n/**\n * Formats a message with the current prefix, if one is set.\n *\n * @since TBD\n *\n * @param {string} message - The message to format.\n *\n * @returns {string} The formatted message with prefix prepended if set.\n */\nfunction formatMessage(message: string): string {\n  if (prefix) {\n    return `[${prefix}] ${message}`;\n  }\n  return message;\n}\n\n/**\n * Prints a green success message to stdout.\n *\n * @since TBD\n *\n * @param {string} message - The success message to display.\n *\n * @returns {void}\n */\nexport function success(message: string): void {\n  console.log(formatMessage(chalk.green(message)));\n}\n\n/**\n * Prints a red error message to stderr.\n *\n * @since TBD\n *\n * @param {string} message - The error message to display.\n *\n * @returns {void}\n */\nexport function error(message: string): void {\n  console.error(formatMessage(chalk.red(message)));\n}\n\n/**\n * Prints a yellow warning message to stdout.\n *\n * @since TBD\n *\n * @param {string} message - The warning message to display.\n *\n * @returns {void}\n */\nexport function warning(message: string): void {\n  console.log(formatMessage(chalk.yellow(message)));\n}\n\n/**\n * Prints a blue informational message to stdout.\n *\n * @since TBD\n *\n * @param {string} message - The informational message to display.\n *\n * @returns {void}\n */\nexport function info(message: string): void {\n  console.log(formatMessage(chalk.blue(message)));\n}\n\n/**\n * Prints a bold title with an underline rule.\n *\n * @since TBD\n *\n * @param {string} message - The title text to display.\n *\n * @returns {void}\n */\nexport function title(message: string): void {\n  console.log('');\n  console.log(formatMessage(chalk.bold(message)));\n  console.log(formatMessage(chalk.bold('='.repeat(message.length))));\n  console.log('');\n}\n\n/**\n * Prints a bold yellow section header.\n *\n * @since TBD\n *\n * @param {string} message - The section header text to display.\n *\n * @returns {void}\n */\nexport function section(message: string): void {\n  console.log('');\n  console.log(formatMessage(chalk.bold.yellow(message)));\n}\n\n/**\n * Prints a plain message to stdout with the current prefix.\n *\n * @since TBD\n *\n * @param {string} message - The message to print.\n *\n * @returns {void}\n */\nexport function log(message: string): void {\n  console.log(formatMessage(message));\n}\n\n/**\n * Prints a message to stdout without any prefix.\n *\n * @since TBD\n *\n * @param {string} message - The message to print.\n *\n * @returns {void}\n */\nexport function writeln(message: string): void {\n  console.log(message);\n}\n\n/**\n * Prints an empty line to stdout.\n *\n * @since TBD\n *\n * @returns {void}\n */\nexport function newline(): void {\n  console.log('');\n}\n","import type { Command } from 'commander';\nimport { getConfig } from '../config.ts';\nimport { runCommand } from '../utils/process.ts';\nimport type { BuildStep, RunCommandResult } from '../types.ts';\nimport * as output from '../utils/output.ts';\n\n/**\n * Runs a single build command, handling the `@` soft-fail prefix.\n *\n * @since TBD\n *\n * @param {string} step - The command string to execute.\n * @param {string} cwd - The working directory for the command.\n *\n * @returns {Promise<{ cmd: string; bailOnFailure: boolean; result: RunCommandResult }>} The command, bail flag, and result.\n */\nasync function runBuildStep(\n  step: string,\n  cwd: string\n): Promise<{ cmd: string; bailOnFailure: boolean; result: RunCommandResult }> {\n  let cmd = step;\n  let bailOnFailure = true;\n\n  if (cmd.startsWith('@')) {\n    bailOnFailure = false;\n    cmd = cmd.slice(1);\n  }\n\n  output.section(`> ${cmd}`);\n\n  const result = await runCommand(cmd, { cwd });\n\n  return { cmd, bailOnFailure, result };\n}\n\n/**\n * Registers the `build` command with the CLI program.\n *\n * @since TBD\n *\n * @param {Command} program - The Commander.js program instance.\n *\n * @returns {void}\n */\nexport function registerBuildCommand(program: Command): void {\n  program\n    .command('build')\n    .description('Run the build commands.')\n    .option('--dev', 'Run the dev build commands.')\n    .option('--root <dir>', 'Set the root directory for running commands.')\n    .action(async (options: { dev?: boolean; root?: string }) => {\n      const config = getConfig(options.root);\n      const buildSteps: BuildStep[] = config.getBuildCommands(options.dev);\n      const cwd = options.root ?? config.getWorkingDir();\n\n      output.log('Running build steps...');\n\n      for (const step of buildSteps) {\n        if (Array.isArray(step)) {\n          // Parallel group: run all commands concurrently\n          const results = await Promise.all(\n            step.map((cmd) => runBuildStep(cmd, cwd))\n          );\n\n          // Check for failures after all parallel commands complete\n          for (const { cmd, bailOnFailure, result } of results) {\n            if (result.exitCode !== 0) {\n              output.error(`[FAIL] Build step failed: ${cmd}`);\n              if (bailOnFailure) {\n                output.error('Exiting...');\n                process.exit(result.exitCode);\n              }\n            }\n          }\n        } else {\n          // Sequential: run single command\n          const { cmd, bailOnFailure, result } = await runBuildStep(\n            step,\n            cwd\n          );\n\n          if (result.exitCode !== 0) {\n            output.error(`[FAIL] Build step failed: ${cmd}`);\n            if (bailOnFailure) {\n              output.error('Exiting...');\n              process.exit(result.exitCode);\n            }\n          }\n        }\n      }\n\n      output.success('Build complete.');\n    });\n}\n","import { createApp } from './app.ts';\nimport { registerBuildCommand } from './commands/build.ts';\n\nconst program = createApp();\n\nregisterBuildCommand(program);\n\nprogram.parseAsync(process.argv).catch((err) => {\n  console.error(err instanceof Error ? err.message : String(err));\n  process.exit(1);\n});\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AA6BA,SAAgB,gBAAgB,GAAmB;CACjD,MAAM,EAAE,KAAK,MAAM,QAAQ,KAAK,MAAM,EAAE;AAExC,KAAI,IAAI,SAAS,EACf,OAAM,IAAI,MAAM,6CAA6C;AAG/D,QAAO,KAAK,KAAK,KAAK,MAAM,KAAK,IAAI;;;;;;;;;;;;;;;ACxBvC,SAAgB,eAAe,MAAc,UAAiC;AAC5E,QAAO;EAAE;EAAM;EAAU;;;;;;;AAQ3B,IAAa,qBAAb,MAAgC;CAC9B,AAAQ,4BAAmC,IAAI,KAAK;;;;;;;;;;CAWpD,IAAI,UAA0B;AAC5B,OAAK,UAAU,IAAI,SAAS,MAAM,SAAS;;;;;;;;;;;CAY7C,IAAI,MAAoC;AACtC,SAAO,KAAK,UAAU,IAAI,KAAK;;;;;;;;;;;CAYjC,IAAI,MAAuB;AACzB,SAAO,KAAK,UAAU,IAAI,KAAK;;;;;;;;;CAUjC,SAAqB;AACnB,SAAO,MAAM,KAAK,KAAK,UAAU,QAAQ,CAAC;;;;;;;;;CAU5C,IAAI,OAAe;AACjB,SAAO,KAAK,UAAU;;;;;;;;;CAUxB,CAAC,OAAO,YAAgC;AACtC,SAAO,KAAK,UAAU,QAAQ;;;;;;;;;;;;ACrFlC,MAAa,kBAAkB,EAAE,MAAM,CAAC,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC;;;;;;AASzE,MAAa,yBAAyB,EAAE,OAAO;CAC7C,MAAM,EAAE,QAAQ;CAChB,OAAO,EAAE,QAAQ;CAClB,CAAC;;;;;;AASF,MAAa,oBAAoB,EAAE,OAAO;CACxC,MAAM,EAAE,QAAQ;CAChB,OAAO,EAAE,QAAQ;CAClB,CAAC;;;;;;AASF,MAAM,mBAAmB,EAAE,OAAO,EAChC,oBAAoB,EAAE,QAAQ,EAC/B,CAAC;;;;;;AAOF,MAAa,wBAAwB,EAAE,OAAO;CAC5C,MAAM,EAAE,QAAQ,CAAC,UAAU;CAC3B,KAAK,EAAE,QAAQ,CAAC,UAAU;CAC1B,MAAM,EAAE,QAAQ,CAAC,UAAU;CAC3B,YAAY,EAAE,QAAQ,CAAC,UAAU;CACjC,aAAa,EAAE,QAAQ,CAAC,UAAU;CAClC,SAAS,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU;CACvC,QAAQ,EAAE,OAAO,EACf,oBAAoB,EAAE,QAAQ,CAAC,UAAU,EAC1C,CAAC,CAAC,UAAU;CACd,CAAC,CAAC,aAAa;;;;;;AAShB,MAAa,qBAAqB,EAAE,OAAO;CACzC,MAAM,EAAE,QAAQ;CAChB,KAAK,EAAE,QAAQ;CACf,MAAM,EAAE,QAAQ;CAChB,YAAY,EAAE,QAAQ;CACtB,aAAa,EAAE,QAAQ;CACvB,SAAS,EAAE,MAAM,EAAE,QAAQ,CAAC;CAC5B,QAAQ;CACT,CAAC;;;;;;AASF,MAAa,2BAA2B,EAAE,OAAO;CAC/C,MAAM,EAAE,QAAQ;CAChB,KAAK,EAAE,QAAQ;CACf,MAAM,EAAE,QAAQ;CAChB,YAAY,EAAE,QAAQ;CACtB,aAAa,EAAE,QAAQ;CACvB,SAAS,EAAE,MAAM,EAAE,QAAQ,CAAC;CAC5B,QAAQ;CACT,CAAC;;;;;;AASF,MAAa,yBAAyB,EAAE,OAAO;CAC7C,aAAa,EAAE,KAAK,CAAC,SAAS,OAAO,CAAC,CAAC,UAAU;CACjD,iBAAiB,EAAE,KAAK,CAAC,SAAS,OAAO,CAAC,CAAC,UAAU;CACrD,MAAM,EAAE,KAAK;EAAC;EAAU;EAAS;EAAO;EAAU,CAAC,CAAC,UAAU;CAC9D,MAAM,EAAE,QAAQ,CAAC,UAAU;CAC3B,SAAS,EAAE,QAAQ,CAAC,UAAU;CAC9B,WAAW,EAAE,QAAQ,CAAC,UAAU;CAChC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,UAAU;CACjD,MAAM,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU;CACpC,kBAAkB,EAAE,QAAQ,CAAC,UAAU;CACvC,YAAY,EAAE,QAAQ,CAAC,UAAU;CAClC,CAAC,CAAC,aAAa;;;;;;AAShB,MAAa,oBAAoB,EAAE,OAAO;CACxC,MAAM,EAAE,QAAQ;CAChB,aAAa,EAAE,KAAK,CAAC,SAAS,OAAO,CAAC,CAAC,QAAQ,QAAQ;CACvD,iBAAiB,EAAE,KAAK,CAAC,SAAS,OAAO,CAAC,CAAC,QAAQ,OAAO;CAC1D,MAAM,EAAE,KAAK;EAAC;EAAU;EAAS;EAAO;EAAU,CAAC,CAAC,QAAQ,MAAM;CAClE,MAAM,EAAE,QAAQ,CAAC,UAAU;CAC3B,SAAS,EAAE,QAAQ,CAAC,UAAU;CAC9B,WAAW,EAAE,QAAQ,CAAC,UAAU;CAChC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC;CAClD,MAAM,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU;CACpC,kBAAkB,EAAE,QAAQ,CAAC,UAAU;CACvC,YAAY,EAAE,QAAQ,CAAC,UAAU;CAClC,CAAC;;;;;;AASF,MAAa,oBAAoB,EAAE,OAAO;CACxC,WAAW,EAAE,QAAQ;CACrB,WAAW,EAAE,QAAQ,CAAC,UAAU;CAChC,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC;CACxB,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC;CACvB,YAAY,EAAE,MAAM,EAAE,QAAQ,CAAC;CAC/B,UAAU,EAAE,MAAM,uBAAuB;CACzC,OAAO,EAAE,MAAM,EAAE,QAAQ,CAAC;CAC1B,SAAS,EAAE,QAAQ;CACpB,CAAC;;;;;;AASF,MAAa,kBAAkB,EAAE,OAAO;CACtC,OAAO,EAAE,MAAM,gBAAgB;CAC/B,WAAW,EAAE,MAAM,gBAAgB;CACnC,WAAW,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;CACpD,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,uBAAuB;CACpD,OAAO,EAAE,MAAM,EAAE,QAAQ,CAAC;CAC1B,MAAM,EAAE,MAAM,CAAC,EAAE,MAAM,sBAAsB,EAAE,sBAAsB,CAAC;CACtE,eAAe;CACf,OAAO;CACP,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC;CACxB,MAAM,EAAE,QAAQ,CAAC,UAAU;CAC3B,wBAAwB,EAAE,SAAS;CACnC,UAAU,EAAE,QAAQ,CAAC,UAAU;CAChC,CAAC,CAAC,aAAa;;;;;;AAShB,MAAa,mBAAmB,EAAE,OAAO;CACvC,OAAO,EAAE,MAAM,gBAAgB,CAAC,UAAU;CAC1C,WAAW,EAAE,MAAM,gBAAgB,CAAC,UAAU;CAC9C,WAAW,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC,UAAU;CAC/D,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,uBAAuB,GAAG,EAAE,OAAO,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,UAAU;CAC9F,OAAO,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU;CACrC,MAAM,EAAE,MAAM,CAAC,EAAE,MAAM,sBAAsB,EAAE,sBAAsB,CAAC,CAAC,UAAU;CACjF,eAAe,mBAAmB,SAAS,CAAC,UAAU;CACtD,OAAO,kBAAkB,SAAS,CAAC,UAAU;CAC7C,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU;CACnC,MAAM,EAAE,QAAQ,CAAC,UAAU,CAAC,UAAU;CACtC,wBAAwB,EAAE,SAAS,CAAC,UAAU;CAC9C,UAAU,EAAE,QAAQ,CAAC,UAAU,CAAC,UAAU;CAC3C,CAAC,CAAC,aAAa;;;;;;AAShB,MAAa,iBAAiB,EAAE,OAAO;CACrC,MAAM,EAAE,QAAQ;CAChB,UAAU,EAAE,MAAM,gBAAgB;CACnC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEhMF,MAAMA,eAAa,cAAc,OAAO,KAAK,IAAI;AACjD,MAAMC,cAAY,KAAK,QAAQD,aAAW;;;;;;AA+B1C,IAAa,SAAb,MAAoB;CAClB,CAASE;CACT,CAASC;CACT,CAASC;CACT;CACA;CACA;CACA,QAAqC;;;;;;;;;;CAWrC,YAAY,YAAqB;EAC/B,MAAM,MAAM,cAAc,QAAQ,KAAK;AAEvC,QAAKF,aAAc,gBAAgB,KAAK,UAAU,IAAI,CAAC;AACvD,QAAKC,gBAAiB,KAAK,KAAK,MAAKD,YAAa,SAAS;AAC3D,QAAKE,SAAU,KAAK,kBAAkB;AACtC,OAAK,yBAAyB;AAC9B,QAAKC,YAAa,KAAK,gBAAgB;AACvC,QAAKC,SAAU,KAAK,kBAAkB;AACtC,QAAKC,eAAgB,KAAK,mBAAmB;;;;;;;;;CAU/C,AAAQ,mBAA8B;AACpC,SAAO,gBAAgBC,wBAAc;;;;;;;;;CAUvC,AAAQ,0BAAgC;AACtC,MAAI,CAAC,GAAG,WAAW,MAAKL,cAAe,CACrC;EAGF,MAAM,gBAAgB,GAAG,aAAa,MAAKA,eAAgB,QAAQ;EACnE,IAAI;AAEJ,MAAI;AACF,cAAW,KAAK,MAAM,cAAc;UAC9B;AACN,SAAM,IAAI,MACR,gGACD;;AAGH,MAAI,CAAC,YAAY,OAAO,aAAa,SACnC,OAAM,IAAI,MACR,+FACD;EAGH,MAAM,cAAc,iBAAiB,UAAU,SAAS;AAExD,MAAI,CAAC,YAAY,SAAS;GACxB,MAAM,SAAS,YAAY,MAAM,OAC9B,KAAK,UAAU,KAAK,MAAM,KAAK,KAAK,IAAI,CAAC,IAAI,MAAM,UAAU,CAC7D,KAAK,KAAK;AACb,SAAM,IAAI,MACR,qFAAqF,SACtF;;EAGH,MAAM,QAAQ,YAAY;EAC1B,MAAM,eAAe,MAAKC;AAE1B,OAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,MAAM,EAAE;GAChD,MAAM,UAAU,aAAa;AAE7B,OAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,iBAAa,OAAO;AACpB;;AAGF,OAAI,OAAO,YAAY,UAAU;AAC/B,iBAAa,OAAO;AACpB;;AAIF,OAAI,QAAQ,YAAY,OAAO,UAAU,YAAY,UAAU,MAAM;IACnE,MAAM,gBAAgB;IACtB,MAAM,YAAY;AAClB,iBAAa,OAAO;AAEpB,SAAK,MAAM,CAAC,WAAW,gBAAgB,OAAO,QAAQ,UAAU,CAC9D,KAAI,cAAc,eAAe,OAC/B,CAAC,aAAa,KAAiC,aAC7C,KAAK,iBAAiB,cAAc,YAAY,YAAY;AAGlE;;AAGF,gBAAa,OAAO,KAAK,iBAAiB,SAAS,MAAM;;;;;;;;;;;;;CAc7D,AAAQ,iBAAiB,UAAmB,QAA0B;AACpE,MAAI,OAAO,WAAW,YAAY,WAAW,KAC3C,QAAO;AAGT,MAAI,OAAO,aAAa,YAAY,aAAa,KAC/C,QAAO;AAGT,MAAI,MAAM,QAAQ,SAAS,CAEzB,QAAO;AAGT,MAAI,MAAM,QAAQ,OAAO,CACvB,QAAO;EAGT,MAAM,OAAO;EACb,MAAM,KAAK;EACX,MAAM,SAAS,EAAE,GAAG,MAAM;AAE1B,OAAK,MAAM,CAAC,KAAK,SAAS,OAAO,QAAQ,KAAK,EAAE;AAC9C,OAAI,GAAG,SAAS,OAAW;AAC3B,OAAI,OAAO,SAAS,YAAY,SAAS,QAAQ,CAAC,MAAM,QAAQ,KAAK,CACnE,QAAO,OAAO,KAAK,iBAAiB,MAAM,GAAG,KAAK;OAElD,QAAO,OAAO,GAAG;;AAIrB,OAAK,MAAM,CAAC,KAAK,SAAS,OAAO,QAAQ,GAAG,CAC1C,KAAI,OAAO,SAAS,OAClB,QAAO,OAAO;AAIlB,SAAO;;;;;;;;;CAUT,AAAQ,iBAAqC;EAC3C,MAAM,aAAa,IAAI,oBAAoB;EAE3C,MAAM,eAAe,MAAKA,OAAQ;AAIlC,MACE,MAAKA,OAAQ,OAAO,SAAS,KAC7B,CAAE,eAA2C,SAE7C,YAAW,IAAI,eAAe,SAAS,MAAKA,OAAQ,MAAM,CAAC;AAG7D,MACE,MAAKA,OAAQ,WAAW,SAAS,KACjC,CAAE,eAA2C,aAE7C,YAAW,IAAI,eAAe,aAAa,MAAKA,OAAQ,UAAU,CAAC;AAGrE,MAAI,gBAAgB,OAAO,iBAAiB,SAC1C,MAAK,MAAM,CAAC,MAAM,aAAa,OAAO,QACpC,aACD,CACC,YAAW,IACT,eAAe,MAAM,MAAM,QAAQ,SAAS,GAAG,WAAW,EAAE,CAAC,CAC9D;AAIL,SAAO;;;;;;;;;;CAWT,AAAQ,mBAA6C;EACnD,MAAM,SAAS,MAAKA,OAAQ;EAC5B,MAAM,yBAAS,IAAI,KAA0B;AAC7C,MAAI,CAAC,OAAQ,QAAO;AAEpB,OAAK,MAAM,CAAC,MAAM,eAAe,OAAO,QAAQ,OAAO,EAAE;GACvD,MAAM,QAAQ,OAAO,eAAe,YAAY,eAAe,OAC3D,aACA,EAAE;GAEN,MAAM,SAAS,kBAAkB,MAAM;IAAE;IAAM,GAAG;IAAO,CAAC;AAC1D,UAAO,IAAI,MAAM,OAAO;;AAG1B,SAAO;;;;;;;;;;;CAYT,AAAQ,oBAAmC;EACzC,MAAM,WAAW,MAAKA,OAAQ,OAAO;EACrC,MAAM,SAAwB,EAAE;AAChC,MAAI,CAAC,YAAY,CAAC,MAAM,QAAQ,SAAS,CAAE,QAAO;AAElD,OAAK,MAAM,MAAM,UAAgC;AAC/C,OAAI,CAAC,GAAG,QAAQ,CAAC,GAAG,MAClB,OAAM,IAAI,MACR,8FACD;GAGH,MAAM,WAAW,KAAK,KAAK,MAAKF,YAAa,GAAG,KAAK;AACrD,OAAI,CAAC,GAAG,WAAW,SAAS,CAC1B,OAAM,IAAI,MAAM,gCAAgC,GAAG,OAAO;GAG5D,MAAM,WAAW,GAAG,aAAa,UAAU,QAAQ;GACnD,MAAM,QAAQ,IAAI,OAAO,GAAG,MAAM;GAClC,MAAM,UAAU,SAAS,MAAM,MAAM;AAErC,OAAI,CAAC,WAAW,CAAC,QAAQ,MAAM,CAAC,QAAQ,GACtC,OAAM,IAAI,MACR,kCAAkC,GAAG,KAAK,iBAAiB,GAAG,MAAM,IACrE;AAGH,UAAO,KAAK;IAAE,MAAM,GAAG;IAAM,OAAO,GAAG;IAAO,CAAC;;AAGjD,SAAO;;;;;;;;;CAUT,IAAI,MAAiB;AACnB,SAAO,MAAKE;;;;;;;;;;;CAYd,iBAAiB,QAAQ,OAAoB;AAC3C,MAAI,SAAS,MAAKA,OAAQ,WAAW,SAAS,EAC5C,QAAO,MAAKA,OAAQ;AAEtB,SAAO,MAAKA,OAAQ,SAAS,EAAE;;;;;;;;;;;CAYjC,YAAY,WAAW,MAAc;EACnC,MAAM,WAAW,MAAKA,OAAQ,OAAO,aAAa;AAClD,MAAI,CAAC,SAAU,QAAO;AACtB,SAAO,KAAK,QAAQ,MAAKF,YAAa,SAAS;;;;;;;;;CAUjD,mBAA6B;AAC3B,SAAO,MAAKE,OAAQ,SAAS,EAAE;;;;;;;;;CAUjC,YAAsC;AACpC,SAAO,MAAKE;;;;;;;;;CAUd,UAAgC;AAC9B,MAAI,MAAKG,SAAU,KAAM,QAAO,MAAKA;EAErC,MAAM,WAAW,MAAKL,OAAQ;EAC9B,MAAM,UAAU,MAAKA,OAAQ;AAE7B,MAAI,CAAC,WAAY,MAAM,QAAQ,QAAQ,IAAI,QAAQ,WAAW,GAAI;AAChE,SAAKK,OAAQ,EAAE;AACf,UAAO,MAAKA;;EAId,IAAI;AACJ,MAAI,CAAC,MAAM,QAAQ,QAAQ,CACzB,WAAU,CAAC,QAAQ;MAEnB,WAAU;AAIZ,YAAU,QAAQ,QACf,SAAS,KAAK,OAAO,KAAK,cAAc,KAAK,KAC/C;AAED,MAAI,QAAQ,WAAW,GAAG;AACxB,SAAKA,OAAQ,EAAE;AACf,UAAO,MAAKA;;AAGd,QAAKA,OAAQ,QAAQ,KAAK,UAAU;GAClC,MAAM,KAAK,QAAQ,SAAS;GAC5B,KAAK,KAAK,OAAO,SAAS;GAC1B,MAAM,KAAK,QAAQ,SAAS;GAC5B,YAAY,KAAK,cAAc,SAAS;GACxC,aAAa,KAAK,eAAe,SAAS;GAC1C,SAAS,KAAK,SAAS,SAAS,KAAK,UAAU,SAAS;GACxD,QAAQ,EACN,oBACE,KAAK,QAAQ,sBACb,SAAS,OAAO,oBACnB;GACF,EAAE;AAEH,SAAO,MAAKA;;;;;;;;;CAUd,iBAA2B;AACzB,SAAO,MAAKL,OAAQ,OAAO,EAAE;;;;;;;;;;;CAY/B,UAAkB;AAChB,MAAI,CAAC,MAAKA,OAAQ,MAAM;GAEtB,MAAM,UAAU,KAAK,KAAK,MAAKF,YAAa,eAAe;AAC3D,OAAI,GAAG,WAAW,QAAQ,EAAE;IAC1B,MAAM,MAAM,KAAK,MAAM,GAAG,aAAa,SAAS,QAAQ,CAAC;AAGzD,QAAI,OAAO,IAAI,eAAe,SAC5B,QAAO,kBAAkB,IAAI,WAAW;AAE1C,QAAI,IAAI,YAAY,IAClB,QAAO,IAAI,WAAW;;GAK1B,MAAM,eAAe,KAAK,KAAK,MAAKA,YAAa,gBAAgB;AACjE,OAAI,GAAG,WAAW,aAAa,EAAE;IAC/B,MAAM,WAAW,KAAK,MACpB,GAAG,aAAa,cAAc,QAAQ,CACvC;AACD,QAAI,SAAS,KACX,QAAO,kBAAkB,SAAS,KAAK;;AAI3C,SAAM,IAAI,MACR,mGACD;;EAGH,MAAM,OAAO,MAAKE,OAAQ;AAE1B,MACE,CAAC,KAAK,SAAS,WAAW,IAC1B,CAAC,KAAK,SAAS,UAAU,IACzB,CAAC,KAAK,SAAS,SAAS,IACxB,CAAC,KAAK,SAAS,iBAAiB,IAChC,CAAC,GAAG,WAAW,KAAK,CAEpB,QAAO,kBAAkB,KAAK;AAGhC,SAAO;;;;;;;;;CAUT,eAAyB;EACvB,MAAM,WAAW;GAAC;GAAc;GAAgB;GAAe;GAAiB;EAChF,MAAM,cAAc,MAAKA,OAAQ,OAAO;AAExC,MAAI,CAAC,eAAe,CAAC,MAAM,QAAQ,YAAY,IAAI,YAAY,WAAW,EACxE,QAAO;AAGT,SAAO,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,UAAU,GAAG,YAAY,CAAC,CAAC;;;;;;;;;CAUpD,kBAAiC;AAC/B,SAAO,MAAKG;;;;;;;;;CAUd,eAAmC;AACjC,SAAO,MAAKF;;;;;;;;;CAUd,gBAAwB;AACtB,SAAO,MAAKH;;;;;;;;;;;CAYd,UAAU,WAAW,MAAc;EACjC,MAAM,SAAS,MAAKE,OAAQ,OAAO,WAAW;AAC9C,MAAI,CAAC,SAAU,QAAO;AACtB,SAAO,KAAK,QAAQ,MAAKF,YAAa,OAAO;;;;;;;;;;;CAY/C,aAAqB;AACnB,MAAI,MAAKE,OAAQ,SACf,QAAO,MAAKA,OAAQ;EAItB,MAAM,UAAU,KAAK,KAAK,MAAKF,YAAa,eAAe;AAC3D,MAAI,GAAG,WAAW,QAAQ,EAAE;GAC1B,MAAM,MAAM,KAAK,MAAM,GAAG,aAAa,SAAS,QAAQ,CAAC;AAGzD,OAAI,IAAI,KAEN,QAAO,IAAI,KAAK,QAAQ,aAAa,GAAG;;EAK5C,MAAM,eAAe,KAAK,KAAK,MAAKA,YAAa,gBAAgB;AACjE,MAAI,GAAG,WAAW,aAAa,EAAE;GAC/B,MAAM,WAAW,KAAK,MACpB,GAAG,aAAa,cAAc,QAAQ,CACvC;AACD,OAAI,SAAS,KACX,QAAO,SAAS,KAAK,QAAQ,YAAY,GAAG;;AAIhD,QAAM,IAAI,MAAM,0CAAwC;;;;;;;;;CAU1D,yBAAkC;AAChC,SAAO,MAAKE,OAAQ,0BAA0B;;;;;;;;;CAUhD,SAAoB;AAClB,SAAO,MAAKA;;;AAIhB,IAAI,eAA8B;;;;;;;;;;AAWlC,SAAgB,UAAU,YAA6B;AACrD,KAAI,CAAC,aACH,gBAAe,IAAI,OAAO,WAAW;AAEvC,QAAO;;;;;;;;;AAUT,SAAgB,cAAoB;AAClC,gBAAe;;;;;AChpBjB,MAAM,aAAa,cAAc,OAAO,KAAK,IAAI;AACjD,MAAM,YAAY,KAAK,QAAQ,WAAW;;;;;;;;AAS1C,SAAS,aAAqB;CAE5B,MAAM,aAAa,CACjB,KAAK,QAAQ,WAAW,MAAM,eAAe,EAC7C,KAAK,QAAQ,WAAW,MAAM,MAAM,eAAe,CACpD;AAED,MAAK,MAAM,aAAa,WACtB,KAAI,GAAG,WAAW,UAAU,CAE1B,QADY,KAAK,MAAM,GAAG,aAAa,WAAW,QAAQ,CAAC,CAChD;AAIf,QAAO;;AAGT,MAAa,cAAc,YAAY;;;;;;;;AASvC,SAAgB,YAAqB;AACnC,cAAa;AAEb,YAAW;CAEX,MAAM,UAAU,IAAI,SAAS;AAC7B,SACG,KAAK,MAAM,CACX,QAAQ,YAAY,CACpB,YAAY,2CAA2C;AAE1D,QAAO;;;;;;;;;;;;;;;;ACjCT,eAAsB,WACpB,SACA,UAAsB,EAAE,EACG;CAC3B,IAAI,MAAM;CACV,IAAI,WAAW,QAAQ,YAAY;AAGnC,KAAI,IAAI,WAAW,IAAI,EAAE;AACvB,QAAM,IAAI,MAAM,EAAE;AAClB,aAAW;;AAGb,KAAI;EACF,MAAM,SAAS,MAAM,MAAM,KAAK;GAC9B,KAAK,QAAQ;GACb,OAAO;GACP,QAAQ,QAAQ,SAAS,SAAS;GAClC,QAAQ,QAAQ,SAAS,SAAS;GAClC,QAAQ;GACT,CAAC;AAEF,MAAI,OAAO,aAAa,KAAK,CAAC,SAC5B,QAAO;GACL,QAAQ,OAAO,OAAO,UAAU,GAAG;GACnC,QAAQ,OAAO,OAAO,UAAU,GAAG;GACnC,UAAU,OAAO,YAAY;GAC9B;AAGH,SAAO;GACL,QAAQ,OAAO,OAAO,UAAU,GAAG;GACnC,QAAQ,OAAO,OAAO,UAAU,GAAG;GACnC,UAAU,WAAW,IAAK,OAAO,YAAY;GAC9C;UACM,KAAc;AACrB,MAAI,SACF,QAAO;GAAE,QAAQ;GAAI,QAAQ,OAAO,IAAI;GAAE,UAAU;GAAG;AAEzD,QAAM;;;;;;ACzDV,IAAI,SAAS;;;;;;;;;;AAmCb,SAAS,cAAc,SAAyB;AAC9C,KAAI,OACF,QAAO,IAAI,OAAO,IAAI;AAExB,QAAO;;;;;;;;;;;AAYT,SAAgB,QAAQ,SAAuB;AAC7C,SAAQ,IAAI,cAAc,MAAM,MAAM,QAAQ,CAAC,CAAC;;;;;;;;;;;AAYlD,SAAgB,MAAM,SAAuB;AAC3C,SAAQ,MAAM,cAAc,MAAM,IAAI,QAAQ,CAAC,CAAC;;;;;;;;;;;AAsDlD,SAAgB,QAAQ,SAAuB;AAC7C,SAAQ,IAAI,GAAG;AACf,SAAQ,IAAI,cAAc,MAAM,KAAK,OAAO,QAAQ,CAAC,CAAC;;;;;;;;;;;AAYxD,SAAgB,IAAI,SAAuB;AACzC,SAAQ,IAAI,cAAc,QAAQ,CAAC;;;;;;;;;;;;;;;ACxHrC,eAAe,aACb,MACA,KAC4E;CAC5E,IAAI,MAAM;CACV,IAAI,gBAAgB;AAEpB,KAAI,IAAI,WAAW,IAAI,EAAE;AACvB,kBAAgB;AAChB,QAAM,IAAI,MAAM,EAAE;;AAGpB,SAAe,KAAK,MAAM;CAE1B,MAAM,SAAS,MAAM,WAAW,KAAK,EAAE,KAAK,CAAC;AAE7C,QAAO;EAAE;EAAK;EAAe;EAAQ;;;;;;;;;;;AAYvC,SAAgB,qBAAqB,SAAwB;AAC3D,SACG,QAAQ,QAAQ,CAChB,YAAY,0BAA0B,CACtC,OAAO,SAAS,8BAA8B,CAC9C,OAAO,gBAAgB,+CAA+C,CACtE,OAAO,OAAO,YAA8C;EAC3D,MAAM,SAAS,UAAU,QAAQ,KAAK;EACtC,MAAM,aAA0B,OAAO,iBAAiB,QAAQ,IAAI;EACpE,MAAM,MAAM,QAAQ,QAAQ,OAAO,eAAe;AAElD,MAAW,yBAAyB;AAEpC,OAAK,MAAM,QAAQ,WACjB,KAAI,MAAM,QAAQ,KAAK,EAAE;GAEvB,MAAM,UAAU,MAAM,QAAQ,IAC5B,KAAK,KAAK,QAAQ,aAAa,KAAK,IAAI,CAAC,CAC1C;AAGD,QAAK,MAAM,EAAE,KAAK,eAAe,YAAY,QAC3C,KAAI,OAAO,aAAa,GAAG;AACzB,UAAa,6BAA6B,MAAM;AAChD,QAAI,eAAe;AACjB,WAAa,aAAa;AAC1B,aAAQ,KAAK,OAAO,SAAS;;;SAI9B;GAEL,MAAM,EAAE,KAAK,eAAe,WAAW,MAAM,aAC3C,MACA,IACD;AAED,OAAI,OAAO,aAAa,GAAG;AACzB,UAAa,6BAA6B,MAAM;AAChD,QAAI,eAAe;AACjB,WAAa,aAAa;AAC1B,aAAQ,KAAK,OAAO,SAAS;;;;AAMrC,UAAe,kBAAkB;GACjC;;;;;ACzFN,MAAM,UAAU,WAAW;AAE3B,qBAAqB,QAAQ;AAE7B,QAAQ,WAAW,QAAQ,KAAK,CAAC,OAAO,QAAQ;AAC9C,SAAQ,MAAM,eAAe,QAAQ,IAAI,UAAU,OAAO,IAAI,CAAC;AAC/D,SAAQ,KAAK,EAAE;EACf"}